TEST("read_error.txt", {
		char *name = "read_error.txt";
		int fd = open(name, O_RDONLY);
		/* 1 */ test_gnl(fd, "aaaaaaaaaa\n");
		/* 2 */ test_gnl(fd, "bbbbbbbbbb\n");
		// set the next read call to return -1
		next_read_error = 1;
		if (BUFFER_SIZE > 100) {
			char *temp;
			do {
				temp = get_next_line(fd);
				free(temp);
			} while (temp != NULL);
		}
		/* 3 */ test_gnl(fd, NULL);
		next_read_error = 0;
		close(fd);
		fd = open(name, O_RDONLY);
		/* 4 */ test_gnl(fd, "aaaaaaaaaa\n");
		/* 5 */ test_gnl(fd, "bbbbbbbbbb\n");
		/* 6 */ test_gnl(fd, "cccccccccc\n");
		/* 7 */ test_gnl(fd, "dddddddddd\n");
		/* 8 */ test_gnl(fd, NULL);
		if (res != 1) {
			fprintf(errors_file, YEL "Probable reason" NC ": You should clear the static buffer when a call to read returns -1\n");
		}
	});

	char *tests[18] = {"9", "9\n", "10", "10\n", "11", "11\n", "19", "19\n", "20", "20\n", "21", "21\n",
		"9\n9\n", "9\n10", "9\n10\n",
		"10\n8\n", "10\n9", "10\n9\n"
	};

	if (BUFFER_SIZE == 10) {
		/*
		 * This tests what happens when newlines are close to the BUFFER_SIZE.
		 * 
		 * For each of the strings defined in char *tests[18] above, it will create a file with what that string encodes. 
		 * 
		 * For example, if the string is: "10\n8\n" it will create a file with 10 chars, a newline, 8 chars and newline.
		 * Then it will use that file as a test for the get_next_line function
		 */
		BASE_TEST("limits", {
			for (int i = 0; i < 18; i++) {
				res = test_limit(tests[i]) && res;
			}
		});
	}
	
texto.txt

aaaaaaaaaa
bbbbbbbbbb
cccccccccc
dddddddddd
